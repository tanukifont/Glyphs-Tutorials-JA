原文: [Creating a variable font](https://glyphsapp.com/learn/creating-a-variable-font)
# バリアブルフォントの作り方

チュートリアル

[ インターポレーション ](https://glyphsapp.com/learn?q=interpolation)

Rainer Erich Scheichelbauer著

[ en ](https://glyphsapp.com/learn/creating-a-variable-font) [ es ](https://glyphsapp.com/es/learn/creating-a-variable-font) [ fr ](https://glyphsapp.com/fr/learn/creating-a-variable-font) [ zh ](https://glyphsapp.com/zh/learn/creating-a-variable-font)

2024年4月21日 2018年3月8日公開

バリアブルフォントは、全く新しい可能性の世界を開きます。Glyphsなら、その作成も簡単です。

## バリアブルフォントとは？

もしあなたがJohn Hudson氏の優れた[入門記事](https://medium.com/@tiro/https-medium-com-tiro-introducing-opentype-variable-fonts-12ba6cd2369)をまだ読んでいないなら、今やっていることをすべてやめて、すぐにその記事を読んでください。本当ですよ。

読み終わりましたか？オーケー。では、ステップバイステップでGlyphsでバリアブルフォントを設定していきましょう。さあ、始めます。

## ステップ1：軸を定義する

インターポレーションを行いたいなら、まず_デザインスペース_を設定する必要があります。デザインスペースは軸によって定義される座標系で、高校で習ったデカルト座標系によく似ています。ただ、x、y、z軸の代わりに、ウェイト、ウェイト、スラントなど、タイポグラフィにとって意味のある_デザイン軸_があります。

そこで、_ファイル > フォント情報 > フォント > 軸_に行き、プラスボタンをクリックして軸を追加します。

![軸の追加](https://glyphsapp.com/media/pages/learn/creating-a-variable-font/6e8835cdef-1715028351/axes-plus.png)
> _ファイル > フォント情報_を選び、_フォント_タブで_軸_の隣にあるプラスアイコンをクリックすると、新しいデザイン軸が追加されます。

表示された軸のエントリで、好きな種類の軸を選びます。公式に「登録」されている軸（ウェイト、ウィズ、イタリック、スラント、オプティカルサイズ）や、[提案されている新しい軸](https://github.com/Microsoft/OpenTypeDesignVariationAxisTags)の範囲から選ぶことができます。あるいは、自分だけの「プライベート」な軸を作ることもできます。

### プロのヒント

自分だけの「プライベート」な軸を作る場合は、4文字のタグも選ぶ必要があります。将来の標準の更新との潜在的な衝突を避けるために、プライベートなタグは_すべて大文字_にすることをお勧めします。例えば、_Smile_には`SMIL`、_Rotation_には`ROTN`のようにです。これは、すべて大文字のタグが公式にプライベート利用のために予約されているからです。定義済みの軸は常に小文字になります。

ほぼいくつでも軸を追加できますが、各軸は一意の4文字の軸タグを持っている必要があります。この例では、一つの「登録」軸である_ウェイト_（定義済みのタグは`wght`）に絞ります。

## ステップ2：マスターを設定する

同じ_ファイル > フォント情報_ウィンドウで、_マスター_タブに切り替え、ウィンドウの左下隅にあるプラスボタンでマスターを追加するか、既存のマスターを複製します。[マルチプルマスターのプロジェクトで行うのと同じようにです](multiple-masters-part-1-setting-up-masters.md)。この例では、_Light_と_Bold_の2つのマスターを追加します。

各マスターについて、次の設定を選びます。

![](images/master-setup.gif)

1.  最も重要なのは、各マスターの**軸座標**を設定することです。この例では、_ウェイト_の値を設定します。例えば、Lightマスターには50、Boldマスターには200です。多くのデザイナーは、ウェイト軸の値としてステムの太さを使用することを好みますが、値が_十分に異なって_いれば、好きなものを入力できます。そうすれば、Glyphsは中間のインスタンスを計算できます。この例では、50から200の間の数値、例えば75、120、182などでインスタンスを計算できます。
2.  各マスターに適切な**マスター名**を選んでいることを確認してください。このケースでは、_Light_と_Bold_が良い選択でしょう。マスター名は最終的なフォントファイルには書き出されません。これらは、Glyphsで作業する際のあなた自身の目印として重要です。
3.  任意で、各マスターの_一般_セクションにある_アイコン_ポップアップから**マスターアイコン**を選びます。さまざまなウェイトとウィズの組み合わせを表す小文字のnの範囲から選択できます。下部にグリフ名を入力することもでき、Glyphsはそのグリフの画像をマスターアイコンとして使用します。これもまた、あなた自身の目印のためなので、自分にとって意味のあるものを選んでください。

オーケー、これでマスターの設定ができました。各マスターに描画を追加していきましょう。

## ステップ3：互換性のあるグリフを描く

短くシンプルに保つため、このチュートリアルでは大文字のAに絞ります。ステム幅が約50ユニットのLightのA（Cmd-1）を描きます。

![](images/a_lightmaster.png)

…そしてステム幅が200ユニットのBoldのA（Cmd-2）です。

![](images/a_boldmaster.png)

_グリフ > アンカーを設定_（Cmd-U）を選択するか、さらに良い方法として、Optionキーを押しながら_グリフ > すべてのマスターにアンカーを設定_（Cmd-Opt-U）を選択してアンカーを追加します。最も重要なのは、[マルチプルマスターの設定で行うのと同じように](multiple-masters-part-2-keeping-your-outlines-compatible.md)、両方のマスター間ですべてのアウトラインとアンカーの互換性を保つことです。

### プロのヒント

_表示 > マスターの互換性を表示_（Ctrl-Opt-Cmd-N）で互換性を確認し、_フィルター > シェイプの順序_で各マスターのシェイプを正しい順序にドラッグできます。

## ステップ4：定義済みのインスタンスを追加する

私たちのフォントはバリアブルであり、すでに無限の数のインスタンスがありますが、それでもデザインスペース内のいくつかのスポットを選び、フォントのサブメニュー用のインスタンスとして定義することができます。_ファイル > フォント情報 > 書き出し_で、好きなだけ定義済みのインスタンスを追加します。左下のプラスボタンで新しいインスタンスを追加するか、左サイドバーの既存のインスタンスエントリをOptionキーを押しながらドラッグして複製します。

![](images/newinstance.png)

各インスタンスで行う必要があるのはこれだけです。

![インスタンスの設定](https://glyphsapp.com/media/pages/learn/creating-a-variable-font/6e8a1e4f41-1715028351/fontinfo_instances.png)

1.  適切な**スタイル名**を設定します。この例では、_Light, Regular, Medium, Semibold, Bold, Extrabold_などです。
2.  任意：_名前_のすぐ下にあるポップアップメニューから**ウェイトクラスとウィズクラス**を選ぶことができます。欠点は、これが関連する_静的_フォントの書き出しにのみ適用され、バリアブルフォントには書き込まれないことです。[命名](naming.md)チュートリアルで詳しく読んでください。
3.  各軸に適切な**デザインスペース座標**を選びます。[マルチプルマスター、パート3](multiple-masters-part-3-setting-up-instances.md)チュートリアルでウェイトの分布について詳しく読んでください。
4.  **スタイルリンク**を選びます。アップライトでは通常これらを空欄のままにしますが、BoldはRegularの_Bold_です。そして、すべてのイタリックは対応するアップライトの_Italic_です。例えば、Semibold ItalicはSemiboldの_Italic_です。ItalicインスタンスのみがRegularの_Italic_で、Bold ItalicがRegularの_Bold and Italic_です。[命名](naming.md)チュートリアルで詳しく読んでください。
5.  残念ながら、**ほとんどのカスタムパラメータはOTVarインスタンスでは機能しません**。特に、ほとんどのフィルターのようなシェイプの後処理を行うものはそうです。インスタンスにそのようなものがあっても、ソフトウェアはそれを blissfuly 無視します。なぜなら、それらはアウトラインの互換性を損なうからです。
6.  任意：インスタンスの（スタイル）名を上書きするために**バリアブルスタイル名**を選びます。_静的_フォントと_バリアブル_フォントの両方の書き出しに同じインスタンスを使用していて、何らかの理由で_静的スタイルとバリアブルスタイルに異なるスタイル名を使用している_場合は、_一般_セクションのこのプロパティでバリアブルスタイル名を具体的に設定できます。

## ステップ5：バリアブルフォント設定を追加する

オーケー、インスタンス内の多くのカスタムパラメータは機能しません。例えば、当然ながら同じバリアブルフォントの異なるインスタンスで異なるグリフセットを持つことはできません。スライダーを動かしたときにグリフが消えたり現れたりするべきではないからです。そのため、インスタンス内の_Export Glyphs_や_Remove Glyphs_パラメータは無視されます。他のパラメータについても同様の論理的な理由が見つかるでしょう。

しかし、もし_バリアブルフォント全体に_パラメータを適用できたらどうでしょう？できます。左下の同じプラスメニューから、_バリアブルフォント設定_を追加します。

![](images/newvfsetting.png)

…そして、_Keep Glyphs_パラメータによるグリフのサブセット化、それぞれのパラメータによるOpenTypeフィーチャーやクラスの変更など、定義したいすべてのことを定義します。

![](images/variablefont-setting.png)

Glyphs 3.1以降では、こちらが私たちの推奨です。

*   **名前：** _フォント全体_がイタリックの場合は_Italic_と呼びます。そうでなければ_Regular_と呼びます。これにより、ローマン体とイタリック体が別々のファイルにあってもスタイルリンクが機能します。
*   **ファミリー名：** 静的フォントとバリアブルフォントの両方を提供する予定がある場合は、_静的_ファミリー名とは異なる必要があります。これは、ユーザーが両方をインストールしてフォントの競合を起こす可能性があるためです。通常、「VF」や「Var」、「Variable」のような追加の識別子を付けた同じファミリー名を使用します。例：「Myfont VF」。アップライトとイタリックが別々のファイルにある場合、このエントリは両方のファイルで同じでなければなりません。
*   **VariationsPostScriptNamePrefix：** 任意。[name ID 25](https://learn.microsoft.com/en-gb/typography/opentype/spec/name#nid25)の設定で、Glyphsはこれから[fvar postScriptNameID](https://learn.microsoft.com/en-gb/typography/opentype/spec/fvar#postScriptNameID)エントリも導出します。これはPS名なので、A-Z、a-z、0-9のみを使用し、スペースや記号、非ASCII文字は使用しないでください。アップライトとイタリックが別々のファイルにある場合、このエントリは異なる必要があります。例：「MyfontVarRoman」と「MyfontVarItalic」。
*   **任意のカスタムパラメータ：** バリアブルフォント設定では、プラスボタンをクリックするとすべての可能なカスタムパラメータが表示されます。_fileName_と_Variable Font Origin_を検討してください。

覚えておいてください：複数のバリアブルフォント設定を持つことができ、同時に複数のバリアブルフォントを書き出すことができます。

## ステップ6：バリアブルフォントを書き出してテストする

_ファイル > 書き出し_を選択し、_バリアブルフォント_タブをクリックします。

![](images/export-otvar.png)

最新のAdobe Illustrator、Adobe Photoshop（CC 2018以降）、またはInDesign（CC 2020以降）をお持ちの場合は、[Adobe Fontsフォルダに書き出して](testing-your-fonts-in-adobe-apps.md)、文字パネルでフォントを選択し、小さなスライダーのポップアップを開いて_ウェイト_軸を試すことができます。

![](images/illustrator.gif)

あるいは、フォントファイルをテストできる素晴らしいウェブページにドロップすることもできます。私のお気に入りは、Roel Niesken氏の素晴らしい[Wakamai Fondue](https://wakamaifondue.com)、ABC Dinamoの[Font Gauntlet](https://dinamodarkroom.com)（バリアブルフォントをアニメーションさせることもできます）、そしてもちろんLaurence Penney氏の[Axis Praxis](https://www.axis-praxis.org)ページです。

![](images/axispraxis.gif)

または、mekkablue scriptsをインストールして_Test > Variable Font Test HTML_を実行すると、最新のOTVar書き出しの隣にHTMLファイルが作成され、Finderでそのフォルダが開きます。あとはそれをブラウザにドラッグするだけです。

### ヒント

この記事を書いている時点では、ブラウザとして最適なのは最新の[Chrome](https://www.google.com/chrome/browser/desktop/index.html)またはSafari（macOS High Sierra以降、またはiOS 11以降で実行している場合）です。Safariは古いOSバージョンではバリアブルフォントをサポートしません。FirefoxとEdgeも機能するはずですが、最新のブラウザバージョンを実行していることを確認してください。

![](images/otvartest.gif)

## バグを回避する

AdobeのOTVar実装にはバグがあります。そのため、IllustratorやPhotoshopでフォントが正しく補間されない場合、それはあなたのフォントのせいではないかもしれません。症状はさまざまですが、グリフが静的なままでスライダーの位置の変更に全く反応しない、またはスライダーを動かすと醜い小さなよじれが現れるなどが含まれます。例：

![](images/ai-glitch.png)

もしそうなった場合は、アウトラインで異なる開始点を設定してみてください。これにより、AIのレンダリングバグを回避できることがあることがわかっています。いずれにせよ、ウェブブラウザで同じ不具合が現れない場合は、あなたのフォントのせいではありません。そして、[Adobeサポートにフォントファイルを送る](https://www.adobe.com/products/wishform.html)のが最善です。簡単なテストケースを含むAIファイルと一緒に送ってください。

> **更新：** 最近のCCバージョンでは、これらのレンダリング問題は非常にまれになりました。実際、CC 2021ではこれらの問題は一つも見ていません。

もう一つの厄介な実装バグは、AppleのレンダラーであるCoreTextの奥深くにあります。LSBが変化する場合、コンポーネントのオフセットが誤って計算されます。aが正しく振る舞うのに対し、a-umlautが必要以上にずれるのを見てください。

![](images/neartatteredcondor-small.gif)

これは、Mac上のほぼすべてのブラウザを含む、CoreTextレンダリングを利用するすべての環境に影響します。その場合、最善の策は、書き出す際にすべてのコンポジットが分解されるようにすることです。最善の方法は、_ファイル > フォント情報 > フォント > カスタムパラメータ_に`Decompose Components in Variable Font`パラメータを追加することです。言うまでもなく、結果として得られるTTFははるかに大きくなり、Appleが問題を修正するまでウェブでの使用には適しません。

~~私たちはAppleにバグを報告しましたが、もし良い事例があれば、[あなたもAppleに知らせてください。](https://bugreport.apple.com)~~

> **更新：** Appleはこの問題を修正しました。macOS 10.13の最新のドットアップデート、またはそれ以降のmacOSを使用していることを確認してください。

![](images/opsz-bug.gif)

Appleのレンダリングにおけるもう一つのバグ：_オプティカルサイズ_軸（`opsz`）がSafariで誤って解釈されます。_原点_マスター（同じ名前のカスタムパラメータで異なる_Variable Font Origin_を指定しない限り、最初のマスター）と一致するスライダーの位置で、_最大_値のレンダリングが表示されます。これはSafariでのみ現れ、他のブラウザでは現れません。繰り返しになりますが、[Appleに知らせてください。](https://bugreport.apple.com)_更新：_このバグにはID FB6055886のフィードバックが提出されています。別のバグを報告する場合は、これを参照してください。

そして、バリアブルフォントがオーバーラップを保持するという事実によって引き起こされるレンダリング問題があります。これは実際にはバグではありませんが、ユーザーにはそう見えるかもしれません。シェイプの端が2つの（部分的に）重なったパスセグメントによって描かれている場合、アンチエイリアシングによってその端が、1つのアウトラインだけで描かれている「きれいな」端よりも暗く見えます。

![](images/overlaps-before.png)

これに対する唯一の解決策は、シェイプの外側の端が常に「きれい」になるように、つまり、どの地点でも1つのパスだけで描かれるようにアウトラインを再配線することです。例えば、このようになります。

![](images/overlaps-after.png)

ほとんどの場合、オーバーラップを削除し、その後コーナーを開くかノードを再接続することでこれを修正できます。_コーナーを開く_と_ノードを再接続_の両方の機能は、それぞれのポイント選択のコンテクストメニューで利用できます。コーナーを開くには個々のコーナーノードを、再接続するにはコーナーノードの_ペア_を選択します。

### プロのヒント

これらの機能を頻繁に使う必要がある場合は、キーボードショートカットを設定すると良いでしょう。この目的のために、_パス > その他_メニューに_ノードを再接続_と_コーナーを開く_を追加しました。ショートカットは_Glyphs > 環境設定 > ショートカット > メニュー_で設定します。

[mekkablue script](https://github.com/mekkablue/Glyphs-Scripts/)の_Paths > Rewire Fire_は、再接続が必要なノードを見つけるのに役立ちます。すべてを見つけることはできませんが、通常、上記で示したようなきれいではないエッジを引き起こすケースの_ほとんど_を見つけることができます。必要なのは、「線分上のノード」を見つけるオプションです。

![](images/rewirefire.png)

## 任意：仮想マスターを追加する

一部のグリフにのみ適用される軸が必要だと想像してください。例えば、A、E、F、Hのような文字には適用されますが、S、D、J、Oなどには適用されず、数字や句読点、記号などの非文字にも適用されないクロスバーの高さなどです。フォント全体に新しいマスターを描くのは意味がないでしょう？むしろ、クロスバーを持つグリフにのみ追加のマスターを導入するべきです。さて、このようなケースのために、_仮想マスター_というものがあります。

1.  _ファイル > フォント情報 > フォント_で、軸パラメータに新しい軸を追加します。これは標準の軸の一つではないので、名前は任意です。この例では、名前を_Crossbar Height_、4文字のタグを_CRSB_とすることをお勧めします。

![](images/newaxis.png)

2.  同じウィンドウタブで、_Virtual Master_というパラメータを追加し、その値として_ウェイト_軸のLightマスターの値（この例では50）と、_Crossbar Height_の最小値（例えばゼロ）を与えます。

![](images/virtualmaster.png)

3.  _ファイル > フォント情報 > マスター_ですべてのマスターを調べ、_Crossbar Height_の軸座標がゼロではなく、例えば100になっていることを確認します。アイデアは、値が何らかの意味で意味を持つようにすることです。このケースでは、ゼロは可能な限り低いクロスバーの位置を表し、100は可能な限り高い位置を表します。すべてのマスターを選択すれば、一度にすべてを編集できます。

![](images/vm-editallmasters.png)

これでフォント情報に仮想マスターが設定されたので、それが必要な各グリフの低いクロスバーのバージョンを描くことができます。

1.  グリフを編集ビューで開きます。
2.  _レイヤー_パレットで、プラスボタンで_Light_レイヤーを複製します。現在の日時を名前として持つバックアップレイヤーが作成されます。
3.  バックアップレイヤーを右クリックし、コンテクストメニューから_レイヤータイプ > 中間レイヤー_を選択して、中間レイヤーに変換します。

![](images/vm-choose-layertype.png)

4.  中間レイヤーをダブルクリックし、表示されるポップアップダイアログで、そのデザインスペース座標をウェイト（この例ではLightマスターを表す50）とクロスバーの高さ（この例では最も低いクロスバーの位置を表す0）に設定します。

![](images/vm-intermediate-layer.png)

5.  次に、クロスバーの高さがゼロのときに文字がどのように見えるべきか、描画を変更します。

![](images/lowcrossbar.png)

ここでのクールな点は、微調整をしない限り、Boldマスター用のブレースレイヤーを追加する必要がないことです。バリアブルフォントでは、2つの軸のデルタ（点の動き）が互いに補完し合い、足し合わせることで低いクロスバーを持つBoldを形成できます。したがって、最善の戦略は、まず1つのマスターでうまくいくか試し、結果が十分でない場合にのみ追加のマスターを追加することかもしれません。

これで終わりです。あとは書き出して、IllustratorやAxis Praxis、Variable Font Test HTMLスクリプトでフォントを再度試すだけです。すると、ほら、2番目の軸が利用可能になり、クロスバーをベースラインに向かって下げることができます。

![](images/2nd_axis.png)

実質的に、私たちはデザインスペースに2番目の次元を追加しました。これを行う場合、マスターを_矩形配置_に保つか、さらに良いことに、原点マスターに対して垂直または水平にオフセットさせることが賢明です。この例では、BoldマスターはLightマスターに対して水平にオフセットしており（最初の座標のみが異なる）、低いクロスバーを持つマスターは垂直にオフセットしています（2番目の座標のみが異なる）。このようにマスターを配置することで、作成した垂直および水平のデルタを単純に足し合わせることで、デザインスペースの矩形内の任意の点に到達できるため、最もコントロールしやすくなります。

## 任意：異なる原点を設定する

フォントには1セットのアウトラインしか保存されません。OTVar非対応のソフトウェアは、これらの「デフォルトのアウトライン」しか表示できません。そのデフォルトは通常、最初のマスターです。しかし、異なるデフォルトを選ぶこともできます。そのためには、_ファイル > フォント情報 > フォント_または_ファイル > フォント情報 > 書き出し_の_バリアブルフォント設定_に行き、_Variable Font Origin_というカスタムパラメータを追加します。その値として、ポップアップメニューからマスターの名前を選びます。

![](images/origin.png)

はい、それは_マスター_でなければなりません。もしあなたの_インスタンス_のいずれかを原点にしたい場合は、そのインスタンスを追加のマスターとして追加する必要があります。_ファイル > フォント情報 > 書き出し_で、原点として定義したいインスタンスを選択し、ウィンドウの左下隅にあるプラスボタンを開き、表示されるポップアップメニューから_インスタンスをマスターとして_を選択します。これで、_ファイル > フォント情報 > マスター_に追加のマスターができ、それを_Variable Font Origin_として設定できます。

考慮すべき2つの点：

1.  **デフォルトの外観：** バリアブルフォントの基本理念の一つは、_最もよく使われるインスタンス_をデフォルトとして選べることです。通常はRegularです。マルチプルマスターでは、デザインスペースの極端な部分（つまり、最も使われないインスタンス）をデザインし、その間のすべてを補間していました。バリアブルフォントは逆の方向に行くことができます。最も重要なアウトライン、デザインスペースのどこか中間にあるものだけを保存し、他のすべてのインスタンスはそこから派生させます。したがって、_デスクトップフォント_の場合、Regularを原点として選ぶか、ユーザーがあなたのフォントファミリーの「デフォルトの外観」として期待するであろうものを選んでください。万が一の場合でも、ユーザーはこのウェイトを使えることになります。
2.  **ファイルサイズ：** 中間のマスターを選ぶと、点のデルタの数が増える可能性が高く、したがって最終的なファイルサイズも増加します。単一軸の設定では、デルタの数が2倍以上になる可能性があります。言い換えれば、_ウェブフォント_の場合、ファイルサイズと読み込み時間を抑えたいので、デザインスペースの_極端な端にあるマスター_の一つを選ぶ方が理にかなっています。

## 何が機能し、何が機能しないか

あなたが慣れ親しんできたことのいくつかは、バリアブルフォントでは期待通りには機能しません。

1.  前述しましたが、_ファイル > フォント情報 > 書き出し_での**カスタムパラメータによる後処理**は、アウトラインの互換性やグリフセットの一貫性を損なう可能性が高いため、すべて無視されます。これにはフィルターやRenameパラメータが含まれます。
2.  **コーナーコンポーネントとセグメントコンポーネント**は機能します。しかし、動作が異なります。バリアブルフォントでは、Glyphsはこれらを補間_前_に適用しますが、クラシックなマルチプルマスター設定では、後から挿入・調整されます。そのため、静的インスタンスとバリアブルインスタンスで結果が少し異なる場合があります。
3.  **中間レイヤーと代替レイヤー**の両方が機能します。
4.  **代替**レイヤーはコンポジットには変換されません。ただし、これにはスクリプトによる解決策があります。詳しくは下記を参照してください。_更新：_ Glyphs 3.1以降では機能するはずです。
5.  **ブラシ**は、すべてのマスターで同じように適用されている限り機能します。
6.  ストロークのような**パス属性**は現在機能しません。TrueTypeカーブへの変換はアウトラインの互換性を損なうためです。

## 必須とも言える：STATテーブル

すべてのバリアブルフォントを含む新しいフォントでは、命名情報はSTATテーブルに保存されます。STATは_Style Attributes_の略で、軸、インスタンス、そして_表示文字列_または_名前文字列_と呼ばれるものに関する情報を含みます。これらは軸上のセクションの名前です。例えば、ウェイト軸はLight、Regular、Medium、Semibold、Boldに、ウィズ軸はCondensed、Regular、Extendedにセクション分けされるかもしれません。

このアイデアの背景には、ユーザーがスライダーをどのように設定しても、アプリケーションがユーザーの現在のインスタンスに名前を付けられるようにするということがあります。実質的に、複数軸の設定では、可能な名前のn次元のフィールドが得られます。例えば、フォントにウェイト軸とウィズ軸がある場合、下の表のようにウェイトの列とウィズの行が得られます。そして、BoldセクションのウェイトとCondensedセクションのウィズの組み合わせに名前を付けるために、アプリケーションは単に表示文字列を組み合わせるだけで、ジャジャーン、「Bold Condensed」の出来上がりです。

![](https://glyphsapp.com/media/pages/learn/creating-a-variable-font/db1cddeafa-1715028351/STAT_Table.svg)

表示文字列は、他の表示文字列と組み合わされたときに省略される場合、_省略可能_と見なされます。通常、これは「Regular」や「Normal」などのデフォルトのスタイル名の場合です。セミボールドのウェイトとレギュラーのウィズの組み合わせは、通常「Semibold Regular」ではなく単に「Semibold」と呼ばれます。また、ノーマルなウェイトとイタリックスタイルの組み合わせは、「Regular Italic」ではなく単に「Italic」と呼ばれます。したがって、表示名「Regular」は省略可能と見なされます。

通常、Glyphsは定義済みのインスタンスの名前を分析することで、これを非常に賢く処理します。しかし、STATテーブルのエントリで表示文字列がファイルに正しく保存されていないことがわかった場合は、_ファイル > フォント情報 > 書き出し_にあるこれら2つのパラメータで制御できます。

*   **Style Name as STAT entry:** インスタンスのスタイル名を、軸範囲の組み合わせ可能な表示文字列として使用します。値として、表示文字列が適用される4文字の軸タグを使用します。これは、1つの軸で非標準であり、他のすべての軸で標準であるインスタンスでのみ使用してください。これは、標準の属性は省略可能な名前を持ち、スタイル名には現れないためです（例：「Semibold」や「Condensed」）。_例：_ Lightインスタンスでは、このパラメータを値_wght_で使います。なぜなら、Lightはウェイト軸上の値だからです。
*   **Elidable STAT Axis Value Name:** パラメータ値で指定された軸に対して、インスタンスのスタイル名を省略可能として宣言します。値として、それぞれの軸の4文字のタグを使用します。通常、このパラメータはレギュラースタイルに追加し、名前が省略可能な表示文字列である各軸に対して1つずつ追加します。_例：_ _Regular_というインスタンスには2つの_Elidable…_パラメータがあり、1つは_wght_、もう1つは_wdth_をパラメータ値として持ちます。

## 軸のマッピングとロケーション

軸についてもう一つ。当然ながら、軸はどこかで始まりどこかで終わります。ユーザーインターフェースでは、軸の始点と終点は（通常は）スライダーの左端と右端の位置で表現されます。その間のすべては、もちろんこれらの極端な点の間に均等に広がっています。言い換えれば、補間の25%を表示するにはスライダーを4分の1の位置に置き、50%を表示するにはちょうど中央に置きます。理にかなっていますよね？

ちょっと待ってください。本当にそうでしょうか？よく考えてみると、それはユーザーがアクセスできるべきインスタンスも、スライダーの_全_範囲にわたって（多かれ少なかれ）_均等_に広がっている場合にのみ意味があります。議論のために、重要な位置がスライダーの狭い範囲に詰め込まれ、スライダーの大部分がユーザーにとってあまり意味をなさない状況を想像してみましょう。

これは実際に_ウェイト_軸（軸タグ`wght`）の場合に起こります。（ほぼすべての）ウェイトの補間では、さまざまなウェイトスタイルは均等に分布していません。最も軽いマスターがどれだけ細く、最も太いマスターがどれだけ太いかによりますが、軸に沿った異なる「焦点」にスタイルがより多く集まることになります。例えば、_非常に細い_ものから「標準的な」、_極端すぎない太さ_へと補間すると、スタイルはスライダーの細い方の端に集中します。

![](images/axis-distribution2.png)

なぜでしょうか？原則として、スライダーの等距離の動きは、スライダーの_どこで_その動きをしても、同じ単位の変化に対応するからです。例えば、ここでの特定の往復運動はデザインを10ユニット変化させ、あそこでの同じ往復運動も10ユニット変化させます。しかし、ステムの太さに10ユニット加えることは、もともと数ユニットしかないHairlineにとっては_非常に大きな_変化です。しかし、全く同じ量がMediumやSemiboldにとっては、ステムの太さに比べてほんのわずかな変化なので、実質的に_無視できる_ほどです。

極端すぎないLightやBook、Regularから、スライダーのもう一方の端にある非常に太いUltra Heavyへと向かう場合は、逆になります。今度は、スタイルはスペクトルの太い方の端に集まります。

![](images/axis-distribution3.png)

どうしてそんなことが可能なのでしょうか？まあ、実際には上記とは逆の状況です。なぜなら、今回変化するのは文字の_白場_だからです。_非常に、非常に_重いデザインでは、白場がほとんど残っていないため、白場に10ユニット加えたり引いたりすることは_非常に大きな_変化です。しかし、平均的なBookとSemiboldのデザインの間の「標準的な」ウェイトの範囲では、依然として同じ状況です。スタイルはより離れています。

これらを合わせると、_非常に細い_ものから_非常に太い_ものへと補間すると、通常、スペクトルの両端にスタイルが集中することが明らかになります。

![](images/axis-distribution1.png)

しかし一方で、ユーザーは私たちの分布の問題など気にしませんよね？ユーザーにとっては、異なるスタイルへのアクセスは、軸全体に均等に分布している場合が最も効果的です。このようになります。

![](images/axis-distribution4.png)

言い換えれば、私たちは均等に分布した_ユーザーがアクセス可能な_位置（「外部座標」）を、適切に分布した_デザイン_の位置（「内部座標」）に何とかして変換する必要があります。このようになります。

![](images/axis-distribution5.png)

これは_軸マッピング_と呼ばれます。私たちは、ユーザーが軸上で_見る_ものを、ユーザーが実際に軸上で_得る_ものにマッピングします。私たちが満たすべき期待される規約があります。

*   **ウェイト軸：** `wght`軸の外部座標は、[usWeightClass](https://docs.microsoft.com/en-us/typography/opentype/spec/os2#usweightclass)の数値と一致することが期待されます。最小値は1、最大値は1000です。値が高いほどフォントは太くなります。期待される外部座標は次の通りです：100 Thin, 200 Extralight, 300 Light, 400 Regular, 500 Medium, 600 Semibold, 700 Bold, 800 Extrabold, 900 Black。Hairlineより軽いものが必要な場合は、最小値の1を使用します。Blackより太いものが必要な場合は、最大値の1000を使用します。これらの追加ウェイトには規定の名前はありませんが、「Laser」や「Hairline」は最も軽いウェイトに、「Extrablack」や「Superheavy」は最も太いウェイトに使われているのを見たことがあります。（[仕様](https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxistag_wght#axis-definition)）
*   **ウィズ軸：** `wdth`軸の外部座標は、[usWidthClass](https://docs.microsoft.com/en-us/typography/opentype/spec/os2#uswidthclass)の仕様で記述されているパーセンテージと一致することが期待されます。「標準的」と認識されるデフォルトの文字幅は100にあると想定されます。よりコンデンスされたデザインはより小さい値を持ち、よりワイドな文字はより高い値を持ちます。これは、デフォルトの幅に対する行長のパーセンテージを大まかに示します。言い換えれば、wdth=50は、フォントが非常にコンデンスされているため、wdth=100で必要なスペースの約半分しか取らないことを意味します。wdth=200では、テキストは約2倍のスペースが必要になります。（[仕様](https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxistag_wdth#axis-definition)）
*   **イタリック軸：** `ital`の外部座標は、アップライト/ローマンで0、イタリックで1と想定されます。0と1の間で補間_できる_ことに注意してください。（[仕様](https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxistag_ital#axis-definition)）
*   **スラント軸：** 外部座標は、反時計回りのスラント角度を度数で大まかに反映するべきで、（理論的には）-90から+90の範囲です。ええ、90°の角度を持つデザインを見てみたいものですが…でも、アイデアはわかりますよね。そして、数学が得意な方々は、角度が最小と最大のスライダー位置の間で線形に分布していないことに気づくでしょうが、まあ、技術者でない人々にとっては十分です。**注意：** 角度は_反時計回り_に測定されるため、10°のスラント角度は`-10`と指定する必要があります。冗談ではありません。そして、アップライトとイタリックと見なすものの間で補間する予定で、ユーザーにイタリックボタンで切り替えさせたい場合は、スラント軸を忘れてイタリック軸を使用してください。（[仕様](https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxistag_slnt#axis-definition)）
*   **オプティカルサイズ軸：** `opsz`の外部座標は、単にポイント単位のタイプサイズで、平均的な読書距離（40cm）でのものです。したがって、標準的なサイズは10〜16ポイントと想定され、opszの値は決してゼロや負になることはありません。（[仕様](https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxistag_opsz#axis-definition)）

他のすべての軸、そしてもちろんカスタム軸には、期待される値はありません。そのような場合、自分をユーザーの立場に置き、自分の書体のユーザーとして意味をなす外部座標を選んでください。ただし、時には非公式に合意された慣習があることもあります。ですから、軸を作成している場合は、[フォーラムで尋ねる](https://forum.glyphsapp.com/)のが最善の策かもしれません。

どの軸を選んでも、_Axis Mappings_パラメータ、または_Axis Location_パラメータの設定という2つの方法でマッピングを実現できます。_Axis Mappings_は単一軸の設定でうまく機能します。複数の次元を持つようになると、_Axis Location_パラメータの方が間違いなく扱いやすく、より正確です。もし私たちに尋ねるなら、_Axis Location_パラメータをお勧めします。

### オプション1：Axis Locationパラメータ

_Axis Location_パラメータを使えば、各マスターとインスタンスの外部座標を正確に定義できます。Glyphsはこの情報を取り込み、各軸の分布を計算します。パラメータは2箇所に追加する必要があります。

1.  _ファイル > フォント情報 > マスター_で、各**マスター**に_Axis Location_パラメータを追加します。すべてのマスターを選択し、一度にパラメータを追加できます。それでも、各外部座標を手動で調整する必要があります。

![](images/axislocation.png)

2.  _ファイル > フォント情報 > 書き出し_で、各**インスタンス**に_Axis Location_パラメータを追加します。これも、マスターと同様に、すべてのインスタンスに一度にパラメータを一括追加できます。もちろん、インスタンスの外部座標はマスターの範囲内でなければなりません。そして、インスタンスがマスターと内部座標を共有している場合、それらは同じ外部座標も共有しなければなりません。理にかなっていますが、言っておく必要があります。

以上です。他に何もすることはありません。次にバリアブルフォントを書き出すと、フォントはユーザーにとって望ましい（外部の）軸分布を持つようになります。クールですね。

もちろん、マスターやインスタンスがたくさんある場合、すべての_Axis Location_設定を編集するのは面倒です。そこで、便利なスクリプトが登場します。詳しくは下記を参照してください。

**注意：** [シェイプを切り替える](switching-shapes.md)場合、ブレースレイヤーやブラケットレイヤー、またはフィーチャーコードの`condition`文の数値を変更しないでください。それらは依然として_内部_の補間値に従います。

### オプション2：Axis Mappingsパラメータ

このようなマッピングは、_Axis Mappings_パラメータとマスター用の_Axis Location_パラメータで実現することもできます。しかし、どのように設定するのでしょうか？簡単です。

### 警告

Axis Mappingsは3.0.xでは常に期待通りに動作するとは限らず、fvarテーブルに不正なエントリを作成する可能性があります。この方法を非推奨にすることを検討しています。可能であれば、Axis Locationメソッドを使用してください。

1.  _フォント情報 > マスター_の各マスターに、適切な外部座標を持つ_Axis Location_パラメータを追加します。外部座標が内部座標と同じ場合は、このステップをスキップできます。このケースでは、内部座標50が外部座標300（LightのusWeightClass）に一致するべきなので、スキップできません。
2.  _フォント情報 > フォント_に_Axis Mappings_パラメータを追加します。
3.  パラメータの値をクリックして編集します。`wght`軸の各ウェイト、`wdth`軸の各ウィズなどに新しい値を追加します。値は、下部のプラスボタンをクリックするか、隣のグラフィックのセグメントをクリックすることで追加できます。

![](images/axis-mappings-adding-values.png)

4.  左の列（またはUIの水平軸）は内部座標を表し、少なくとも設定したインスタンスと一致するようにしてください。ただし、より詳細に設定することもできます。右の列（またはUIの垂直軸）は外部座標を表し、これらは上記の規約に一致するべきです。

この例では、_Axis Mappings_は最終的にこのようになるかもしれません。

![](images/axis-mappings.png)

### 軸の分布をテストする

通常、軸マッピングは、スライダーを一方の端からもう一方の端までドラッグしたときのフォントの振る舞いに微妙な変化しかもたらさないでしょう。そのため、すべてが意図した通りに機能したかを確認するのは難しいでしょう。したがって、`avar`テーブルを検査するための特別なツールが必要です。幸いなことに、[Laurence Penney氏のSamsa](https://www.axis-praxis.org/samsa/)がそのようなツールです。フォントをページにドラッグし、_Axes_インスペクタで_Show avar_オプションをオンにします。

![](images/samsa-avar.png)

そして、スライダーをドラッグすると、表示されるスライダーの位置（上）が実際のデザイン分布（下）にどのようにマッピングされるかを示す緑色の矢印が表示されます。視覚化の上にマウスをホバーし、ツールチップが表示されるのを待つと、さらにマニアックな情報を得ることができます。

![](images/samsa-tooltip.png)

説明すると、`avar`の値は-1.0、0.0、+1.0の間で変動します。Glyphsは通常、補間を0.0と+1.0の間に置きます。言い換えれば、`avar`では、Lightマスターが0.0に、Boldマスターが+1.0に対応します。例えば、上の写真のツールチップは、現在のスライダー位置550.4（0.562988...または56.3%）が、実際のデザイン位置540.38（0.550476…または55%）、つまりMedium（500）とSemibold（600）の中間に対応することを示しています。

## 便利なスクリプト

[mekkablue scripts collection](https://github.com/mekkablue/Glyphs-Scripts/)（リンクにはインストール手順を含むreadmeが含まれています）には、バリアブルフォントの作成に役立ついくつかの便利なスクリプトがあります。

1.  **Interpolation > Composite Variabler:** コンポジット内で使用されているコンポーネントの[代替レイヤー](alternating-glyph-shapes.md)を再複製します。これにより、コンポジット内でもブレースレイヤーが機能するようになります。例えば、太くなるにつれて二階建てから一階建てのデザインに切り替わるブレースレイヤーを持つ小文字の`g`がある場合、コンポジットの`gcircumflex`、`gcommaaccent`、`gbreve`でブラケットレイヤーを再複製する必要があります。スクリプトを実行した後も、ブラケットレイヤーを分解する必要があります。

![](images/mekkablue-compound-variabler.png)

**更新：** Composite VariablerはGlyphs 3ではもう必要ないはずです。これを修正するための緊急ハックとしてのみ使用してください。

2.  **Kerning > Zero Kerner:** あるマスターには存在しないが他のマスターには存在するペアに対して、値ゼロのグループカーニングを追加します。OTVarの書き出しで補間可能なカーニングを維持するのに役立ちます。一部のマスターにしか存在しないカーニングペアなど、一部のカーニングが失われる場合にこれを使用してください。

![](images/mekkablue-zero-kerner.png)

**更新：** Zero KernerはGlyphs 2.6.5、ビルド1300以降ではもう必要ないはずです。

3.  **Interpolation > Set Weight Axis Locations in Instances:** すべてのインスタンスに対して、そのウェイトクラスに基づいて_Axis Location_パラメータを設定しようとします（例：Semiboldには600）。マスターがインスタンスと一致し、軸ロケーションが割り当てられていない場合、インスタンスと同じ軸ロケーションが割り当てられます。（同じ機能は_Insert Instances_スクリプトにも組み込まれています。）隠された追加機能：インスタンスにウィズクラスが設定されていて、ウィズ軸の軸ロケーションがまだ利用できない場合、ウィズ軸のロケーションも設定しようとします。
4.  **Interpolation > Axis Location Setter:** インスタンスとマスターの内部および/または外部座標を、スタイル名に基づいて（再）設定します。例えば、「Semibold」という名前を含むすべてのインスタンス（Condensed Semibold Italic、Wide Semiboldなど）は、内部ウェイト軸座標140、外部軸ロケーション600を持つべきです。複数軸設定でインスタンスを一括移動するのに便利です。

![](images/script-axis-location-setter.png)

5.  **Interpolation > Instance Cooker:** 各軸の定義済みロケーションからすべてのインスタンスを一括作成します。多くの軸があり、多くのインスタンスを作成する必要がある場合に非常に便利です。UIでの説明：

![](images/script-instance-cooker.png)

6.  **Font Info > OTVAR Maker:** _ファイル > フォント情報 > 書き出し_でバリアブルフォント設定を（一括）作成するのに役立ちます。

![](images/script-otvar-maker.png)

7.  **Post Production > Fix Italic PS Names (OTVAR):** イタリックのバリアブルフォントを書き出した後にこれを実行すると、スクリプトは書き出された`fvar`テーブルの`postScriptNameID`エントリを修正します。具体的には、「Italic」の二重命名を修正します。つまり、`MyfontItalic-MediumItalic`を推奨される`MyfontItalic-Medium`に変換します。その進捗はマクロウィンドウに出力されます。

## 追加リソース

バリアブルフォントについてさらに深く掘り下げて知りたいですか？いくつかのリンクをご紹介します。

*   Microsoft: [ OpenType specification ](https://docs.microsoft.com/en-us/typography/opentype/spec/)
*   Microsoft GitHub: proposals for new [ OpenType Design Variation Axis Tags ](https://github.com/Microsoft/OpenTypeDesignVariationAxisTags)
*   Tom Rickner’s background story, [ ‘From TrueType GX to Variable Fonts’ ](https://www.monotype.com/resources/articles/part-1-from-truetype-gx-to-variable-fonts/)
*   Irene Vlachou’s barebones guide to [ Building variable fonts with Feature Variations ](https://github.com/irenevl/variable-fonts-with-feature-variations)
*   Roel Niesken’s [ Wakamai Fondue ](https://wakamaifondue.com) (‘What can my font do?’)
*   ABC Dinamo’s [ Font Gauntlet ](https://fontgauntlet.com)
*   Pangram Pangram’s [ TypeTrials ](http://typetrials.com)
*   Laurence Penney’s [ Axis Praxis ](https://www.axis-praxis.org)
*   Laurence Penney’s [ Samsa ](https://www.axis-praxis.org/samsa/) for variable font analysis ( [ source code on GitHub ](https://github.com/Lorp/samsa) )
*   [ Font Drop ](https://fontdrop.info) by the Nübel brothers
*   Travis Kochel’s [ I Can Variable Font ](https://github.com/scribbletone/i-can-variable-font) , ‘notes on generating variable fonts’
*   Andrey Kuzmin’s [ Font Dimensions ](https://github.com/w0rm/elm-font-dimensions) , a tool to visualize dimensions of a variable font
*   Underware’s fun showcase and proofs-of-concept: [ Very Able Fonts ](http://very-able-fonts.com)
*   Nick Sherman’s track-keeping of variable font releases: [ V-Fonts ](https://v-fonts.com/) , ‘a simple resource for finding and trying variable fonts’
*   Christoph Koeberlin’s [ variable fonts resource list ](https://typefacts.com/links/variable-fonts) with many useful links (partially in German, but don’t let that scare you off)

STATテーブルのサンプルフォント：Plantago by Viktor Solt-Bittner and Schriftlabor.
このチュートリアルへのコメントとアドバイスをくれたRob McKaughan氏に感謝します。

---

更新履歴 2018-03-16: いくつかの誤字を修正（Jeff Kellem氏に感謝）。

更新履歴 2018-06-22: サンプル値の表現を明確化（Karl氏に感謝）。

更新履歴 2018-11-20: _Variable Font Origin_パラメータの命名を更新。

更新履歴 2019-02-15: Font GauntletとWakamai Fondueのリンクを追加。テストスクリプトとブラウザサポート情報を更新。「バグの回避」を追加。

更新履歴 2019-03-13: 「追加リソース」を追加。

更新履歴 2019-03-04: 誤字を修正し、書き出しウィンドウの「Variation Fonts」を「Variable Fonts」に置き換え（Nathalie Dumont氏に感謝）。

更新履歴 2019-03-20: 誤字を修正し、「Add Instance as Master」を「Instance as Master」に置き換え、Nick Sherman氏のV-Fontsへのリンクを修正（Nathalie Dumont氏に感謝）。

更新履歴 2019-10-23: 「便利なスクリプト」を追加。

更新履歴 2019-12-04: アンチエイリアシング問題に関するセクションを追加。

更新履歴 2020-03-08: Safariのopszバグに関する段落、「Rewire Fire」スクリプトに関するヒント、リソースにSamsaを追加。

更新履歴 2020-06-14: 「軸のマッピング」の章を追加、「便利なスクリプト」を更新、SafariのopszバグのGIFを追加。

更新履歴 2020-07-09: 「Rewire Fire」スクリプトに関する段落の表現を軽微に変更。

更新履歴 2020-11-17: Glyphs 3向けに部分的に適応。

更新履歴 2020-12-14: 大部分とスクリーンショットをGlyphs 3向けに更新。

更新履歴 2022-04-19: 「軸のマッピングとロケーション」を書き直し（独立した「任意：軸ロケーション」の章を削除）。軸ロケーション用の新しい便利なスクリプトを追加。

更新履歴 2023-10-16: バリアブルフォント設定の提案と2つの新しいスクリプトを追加、Font Gauntletのリンクを更新。

更新履歴 2023-12-02: Safariのopszバグの説明を改善、Apple Feedback IDを追加。

更新履歴 2024-04-21: Type TrialsのURLを追加。

## 関連記事

[すべてのチュートリアルを見る →](https://glyphsapp.com/learn)

*   ### [マルチプルマスター、パート1：マスターの設定](multiple-masters-part-1-setting-up-masters.md)

チュートリアル

[ インターポレーション ](https://glyphsapp.com/learn?q=interpolation)

*   ### [マルチプルマスター、パート2：アウトラインの互換性を保つ](multiple-masters-part-2-keeping-your-outlines-compatible.md)

チュートリアル

[ インターポレーション ](https://glyphsapp.com/learn?q=interpolation)

*   ### [マルチプルマスター、パート3：インスタンスの設定](multiple-masters-part-3-setting-up-instances.md)

チュートリアル

[ インターポレーション ](https://glyphsapp.com/learn?q=interpolation)

*   ### [シェイプを切り替える](switching-shapes.md)

チュートリアル

[ インターポレーション ](https://glyphsapp.com/learn?q=interpolation)